"use strict";

var events = require('events');
var async = require('async');
var websocket = require('websocket');
var util = require('./util');

var Trigger = function () {
  this.connections = [];
};

Trigger.prototype = Object.create(events.EventEmitter.prototype);

Trigger.prototype.send = function (object, callback) {
  this._send('custom', object, callback);
};

Trigger.prototype._send = function (type, object, callback) {
  var data = {
    type: type,
    data: object
  };
  async.each(this.connections, function (conn, next) {
    conn.sendUTF(JSON.stringify(data));
    next(null);
  }, function (err) {
    callback && callback(err);
  })
};

Trigger.prototype.on_message = function (conn, msg) {
  if (msg.type === 'utf8') {
    var data = JSON.parse(msg.utf8Data);
    switch (data.type) {
      case 'addresses':
        this.set_addresses(data.data);
        break;
      case 'custom':
        this.emit('message', data.data);
        break;
      default:
        break;
    }
  }
};

Trigger.prototype.on_error = function (conn, error) {
  this.emit('error', error);
};

Trigger.prototype.on_close = function (conn, code, desc) {
  this.emit('close', code, desc);
};

Trigger.prototype.insert = function (conn) {

  var self = this;

  conn.on('error', function (error) {
    self.on_error(conn, error);
  });

  conn.on('message', function (msg) {
    self.on_message(conn, msg);
  });

  conn.on('close', function (code, desc) {
    self.remove(conn);
    self.on_close(conn, code, desc);
  });

  this.connections.push(conn);
};

Trigger.prototype.remove = function (conn) {
  var index = this.connections.indexOf(conn);
  0 <= index && this.connections.splice(index, 1);
};

function address(httpServer) {
  var addr = httpServer.address();
  if (addr.address === '0.0.0.0') {
    addr.address = util.getLocalAddress().ipv4[0].address;
  }
  return [addr.address, addr.port].join(':');
}

/**
 * httpServerを元にwebsocketサーバを起動する
 * @param httpServer
 * @returns {Trigger}
 */
Trigger.prototype.listen = function (httpServer) {
  var self = this;
  this.address = address(httpServer);
  this.server = new websocket.server({httpServer: httpServer});
  this.server.on('request', function (req) {
    var conn = req.accept(null, req.origin);
    self.insert(conn);
    // addresses を通知する
    self._send('addresses', self.get_addresses());
  });
  return this;
};

// addresses を取得する
Trigger.prototype.get_addresses = function () {
  var addresses = [];
  this.address && addresses.push(this.address);
  this.connections.forEach(function (conn) {
    conn.address && addresses.push(conn.address);
  });
  return addresses;
};

// addresses を設定する
// 一覧に存在しない場合、新たに接続する
Trigger.prototype.set_addresses = function (new_addresses) {
  var self = this;
  var addresses = self.get_addresses();
  new_addresses.forEach(function (address) {
    if (addresses.indexOf(address) === -1) {
      self.connect(address);
    }
  });
};

/**
 * websocketサーバに接続する
 * @param address
 * @returns {Trigger}
 */
Trigger.prototype.connect = function (address, callback) {
  var self = this;
  address = check_local(address);
  var client = new websocket.client();
  client.connect('ws://' + address + '/');
  client.on('connect', function (conn) {


    // todo
    // addresses 情報として保存しておく
    conn.address = address;


    self.insert(conn);
    callback && callback(null);
  });
  return this;
};

// localhostの場合にIPアドレスに変換する
function check_local(address) {
  var a = address.split(':');
  switch (a[0]) {
    case 'localhost':
    case '127.0.0.1':
      a[0] = util.getLocalAddress().ipv4[0].address;
      break;
  }
  return a.join(':');
}

/**
 * Close
 * @param callback
 */
Trigger.prototype.close = function (callback) {
  var self = this;
  async.each(this.connections, function (conn, next) {
    conn.close();
    next(null);
  }, function (err) {
    self.server && self.server.close();
    callback && callback(err);
  });
};

module.exports = Trigger;
